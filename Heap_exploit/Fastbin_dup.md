# Fastbin_dup

## conditions

* 공격자에 의해 동일한 크기의 fast chunk의 할당과 해제가 자유로워야 한다.
* 공격자에 의해 해제된 fast chunk를 한 번더 해제할 수 있어야 한다. _(Double free bug)_

## Exploit plan

1. 동일한 크기의 fast chunk 3개를 생성한다.
2. 첫 번째 chunk를 해제한다.
3. 두 번째 chunk를 해제한다.
4. 해제된 첫 번째 fast chunk를 한번 더 해제한다.
5. 공격 대상 영역과 같은 크기의 fast chunk 3개를 할당한다. -> 첫 번째 Heap chunk와 세 번째 Heap chunk의 주소가 같아진다.

## Example

```c
#include <stdio.h>
#include <stdlib.h>
 
int main()
{
        int *buf1 = malloc(112);
        int *buf2 = malloc(112);
        int *buf3 = malloc(112);
 
        free(buf1);
        free(buf2);
        free(buf1);
 
        int *buf4 = malloc(112);
        int *buf5 = malloc(112);
        int *buf6 = malloc(112);
}
```

![1501828123712.jpg](https://www.lazenca.net/download/attachments/1148141/1501828123712.jpg?version=1&modificationDate=1501860540662&api=v2)

* fastbins은 free chunk를 Single list로 관린하고 있다.
  * 동일한 크기의 fast chunk가 여러 개 해제되면, chunk header의 fd영역을 이용해 관리한다.
* Double free를 하면 이미 free list에 존재하는 chunk이지만 다시 chunk head에 들어가게 되므로 fastbinY에 chunk가 두 개밖에 없을 경우 서로를 가리키게 된다.
* free list에 chunk가 하나밖에 없을 때 double free로 해도 될 것 같지만 그렇게 되면 crash가 발생한다고 한다. 아마 double free를 검사하는 routine이 해당 chunk가 free list의 head인지만 검사하는 것 같다.

## How to see fastbins?

```
gdb-peda$ p main.arena.fastbinsY
```

