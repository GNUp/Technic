# unsafe unlink

## conditions

* 공격자에 의해 생성된 heap 영역이 전역변수에 의해 관리되어야 한다.
* 크기가 0x80 이상의 heap 영역을 공격자가 할당할 수 있어야 한다.
* 공격자에 의해 1번째 heap (Allocated)영역에 fake chunk를 저장할 수 있어야 한다.
* 공격자에 의해 2번째 heap (Allocated)영역에 header를 덮어쓸 수 있어야 한다.
  * Allocated chunk의 size 값에서 PREV_INUSE 가 제거되어야 한다.
* 공격자에 의해 2번째 heap 영역을 해제할 수 있어야 한다.

## Exploit plan

1. 2개의 heap 영역을 할당한다.
   * heap size : 0x80
   * 할당받은 첫번째 heap 영역의 주소는 전역변수에 저장
2. 1번째 heap 영역에 fake chunk 구조를 저장한다.
   * fd: 전역변수 주소 - 0x18
   * bk: 전역변수 주소 - 0x10
3. 2번째 heap 영역의 header값을 변경한다.
   * `prev_size`설정: 0x90 - 0x10 = 0x80
   * `PREV_INUSE` flag 해제: 0x91 - 0x1 = 0x90
   * 2 번째 heap 영역이 free chunk 구조로 변경된다.
4. 2번째 heap 영역을 해제한다.
5. 전역변수 영역에 fake chunk의 fd값이 저장된다.
   * fd에 전역변수의 주소 값이 들어있으니 heap 영역에 데이터가 써지는 대신 전역변수 영역에 데이터가 써질 것이고 임의의 주소값을 넣을 수 있다.
6. 전역변수[3] 영역에 공격자가 접근하려는 주소 값을 저장한다.
   * 전역변수를 통해 원하는 영역에 값을 쓸 수 있다.
   * 원래의 의도는 전역변수에 저장된 heap 영역의 주소를 통해 heap 영역에 데이터를 써야하는데 공격자가 설정한 주소에 데이터를 쓸 수 있게 되는 것이다.

__결론: 전역변수에 특정한 주소값을 적어서 exploit에 이용할 수 있다.__

- PIE가 걸려있어서 .data, .bss 영역의 주소값이 일정하지 않으면 무용지물이 될 듯 하다.
- heap header영역의 값을 변경하기 위해서는 heap overflow가 필요하다.

## `FD`->`bk` != `P` || `BK`->`fd` != `P`

* `unlink()`에서 `P`->`fd`->`bk`, `P`->`bk`->`fd` 의 값이 `P`의 값과 다른지 확인한다.
  * 값이 다를 경우 Error 메세지를 출력한다.
    * "corrupted double-linked list"
* 위의 조건을 우회하기 위해 fake chunk가 필요한 것
  * `fd`영역에 "fake chunk 주소가 저장된 변수의 주소 - 0x18" 값을 저장한다.
  * `bk` 영역에 "fake chunk 주소가 저장된 변수의 주소 - 0x10" 값을 저장한다.
* 이렇게 만들면 `P`->`fd`->`bk` 와 `P`->`bk`->`fd` 의 값이 전역변수에 저장된 P의 주소를 가리키게 되고 둘의 값이 같아서 조건을 우회할 수 있게 된다.

## chunksize(P) != prev_size (next_chunk(P))

* `unlink()` 함수에서 `P`->size와 next chunk->prev_size의 값이 다른지 확인하다.
  * 값이 다를 경우 "corrupted size vs. prev_size" Error 메시지를 출력한다.
* 이 조건을 우회하기 위해 fake chunk가 필요하다.
  * prev_size: 0x00
  * size: 0x00
* 해당 취약성은 heap 영역을 재할당 받기 위한 것이 아니기 때문에 prev_size, size 영역에 0x0을 저장해 해당 조건을 우회만 한다.
  * size 영역의 값이 0x0이기 때문에 next chunk의 주소는 fake chunk의 주소가 된다.
    * P->size: 0x00
    * next chunk->prev_size: 0x00(fake chunk의 prev_size 영역)



__#define unlink(AV, P, BK, FD)__

free가 불렸을 때, consolidate가 일어나는 상황에서만 불리는 매크로 함수이다. 이 때문에 2번째 heap 영역의 `PREV_INUSE` bit를 해제한다.

```c
/* Take a chunk off a bin list */
#define unlink(AV, P, BK, FD) { //여기에 넘어오는 것은 consolidate된 free chunk의 주소 그러므로 fake chunk주소가 P로 들어온다. 실제로 free하는 것은 두 번째 heap 영역
    if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      
      malloc_printerr (check_action, "corrupted size vs. prev_size", P, AV);  
    FD = P->fd;                                    
    BK = P->bk;                                    
    if (__builtin_expect (FD->bk != P || BK->fd != P, 0))           
      malloc_printerr (check_action, "corrupted double-linked list", P, AV);  
    else {                                    
        FD->bk = BK;//unlink 과정의 핵심
        BK->fd = FD;//이부분의 순서 때문에 전역변수 영역이 fack chunk의 FD로 바뀌는 것
        if (!in_smallbin_range (chunksize_nomask (P))                 
            && __builtin_expect (P->fd_nextsize != NULL, 0)) {             
        if (__builtin_expect (P->fd_nextsize->bk_nextsize != P, 0)          
        || __builtin_expect (P->bk_nextsize->fd_nextsize != P, 0))    
          malloc_printerr (check_action,                      
                   "corrupted double-linked list (not small)",    
                   P, AV);                        
            if (FD->fd_nextsize == NULL) {                     
                if (P->fd_nextsize == P)                   
                  FD->fd_nextsize = FD->bk_nextsize = FD;           
                else {                                
                    FD->fd_nextsize = P->fd_nextsize;               
                    FD->bk_nextsize = P->bk_nextsize;               
                    P->fd_nextsize->bk_nextsize = FD;               
                    P->bk_nextsize->fd_nextsize = FD;               
                  }                               
              } else {                                
                P->fd_nextsize->bk_nextsize = P->bk_nextsize;            
                P->bk_nextsize->fd_nextsize = P->fd_nextsize;            
              }                                   
          }                                   
      }                                       
}
```

Fake chunk 구조

- ```__builtin_expect (FD->bk != P || BK->fd != P, 0)```

  - P→fd : 0x601048
  - P→bk : 0x601050 
  - P→fd→bk : 0x602010
  - P→bk→fd : 0x602010

- ```__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)```

  - P→size : 0x0
  - next chunk : 0x602010 + 0x0 = 0x602010 
  - next chunk→prev_size : 0x0

![img](https://www.lazenca.net/download/attachments/1148137/1501816764236.jpg?version=1&modificationDate=1501849284607&api=v2)

## Example

```c
#include <stdio.h>
#include <stdlib.h>
 
char *buf1;
 
void main(){
    buf1 = malloc(0x80);
        printf("buf1 : %p\n",&buf1);
 
    char *buf2 = malloc(0x80);
    scanf("%144s",buf1);
 
    free(buf2);
     
    scanf("%32s",buf1);
    scanf("%128s",buf1);
}
```

![img](https://www.lazenca.net/download/attachments/1148137/1507706526486.jpg?version=1&modificationDate=1507738945749&api=v2)

2 번째 chunk를 해제하는 과정에서 fake chunk를 통해 fd의 값이 bk가 가리키는 chunk에 쓰여진다. 사실 bk에 쓰여져 있는 주소값은 전역변수 영역의 주소이지만 unlink()함수는 chunk라고 생각하기 때문에 bk에 쓰여진 주소를 기준으로 이를 chunk라고 봤을 때 fd영역에 fake chunk의 fd가 쓰여진다. 이는 왜그럴까?



fake chunk는 unlink과정에서의 검사를 우회하기 위해서 존재한다.